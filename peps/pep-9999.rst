PEP: 9999
Title: Unpacking in Comprehensions
Author: Adam Hartz <hz@mit.edu>, Erik Demaine <edemaine@mit.edu>
Sponsor: TBD
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 22-Jun-2025
Python-Version: 3.15
Post-History: `16-Oct-2021 <https://mail.python.org/archives/list/python-ideas@python.org/thread/7G732VMDWCRMWM4PKRG6ZMUKH7SUC7SH/>`__, `22-Jun-2025 <https://discuss.python.org/t/pre-pep-unpacking-in-comprehensions/96362>`__


Abstract
========

This PEP proposes extending list, set, and dictionary comprehensions, as well
as generator expressions, to allow unpacking notation (``*`` and ``**``) at the
start of the expression.  For example, ``[*it for it in its]`` becomes
shorthand for ``[x for it in its for x in it]``.  This notation makes it easy
to combine an arbitrary number of iterables into one list or set or generator,
or an arbitrary number of dictionaries into one dictionary.


Motivation
==========

Extended unpacking notation (``*`` and ``**``) from PEP 448 makes it
easy to combine a few iterables or dictionaries::

    [*it1, *it2, *it3]  # list with the concatenation of three iterables
    {*it1, *it2, *it3}  # set with the union of three iterables
    {**dict1, **dict2, **dict3}  # dict with the combination of three dicts

This PEP proposes extending this pattern to enable combining an arbitrary
number of iterables or dictionaries, via comprehensions::

    [*it for it in its]  # list with the concatenation of iterables in 'its'
    {*it for it in its}  # set with the union of iterables in 'its'
    {**d for d in dicts} # dict with the combination of dicts in 'dicts'

In addition, it defines an analogous notation for generator expressions::

    (*it for it in its)  # generator of the concatenation of iterables in 'its'

The new notation listed above is effectively short-hand for the
following existing notation::

    [x for it in its for x in it]
    {x for it in its for x in it}
    {key: value for d in dicts for key, value in d.items()}
    (x for it in its for x in it)

The new notation is more concise, avoiding the use and repetition of auxiliary
variables, and possibly more intuitive to programmers familiar with both
comprehensions and unpacking notation.  The dictionary version can also be
implemented so as to be more efficient than the example above by avoiding item
tuple creation and unpacking.

Alternatively, the notation is effectively short-hand for the following uses of
``itertools.chain``::

    list(itertools.chain(*its))
    set(itertools.chain(*its))
    dict(itertools.chain(*(d.items() for d in dicts)))
    itertools.chain(*its)

Rationale
=========

In the proposed notation, ``[*it for it in its]`` is analogous to
``[*its[0], *its[1], ..., *its[len(its)-1]]`` (pretending that ``its``
is a list so supports indexing) in the same way that
``[it for it in its]`` is analogous to
``[its[0], its[1], ..., its[len(its)-1]]``.
The same analogy holds for the set, dictionary, and generator
versions.

This proposal was motivated in part by a written exam in a Python programming
class, where several students used the notation (specifically the ``set``
version) in their solutions, assuming that it already existed in Python.  This
suggests that the notation is intuitive, even to those who are learning Python.
By contrast, the existing syntax ``[x for it in its for x in it]`` is one that
students often get wrong, with the natural impulse for many students being to
reverse the order of the ``for`` clauses.

An example where this new notation is especially convenient (albeit suboptimal
in efficiency) is a recursive function that accumulates the set of values from
the leaves of a tree::

    def leaf_values(node):
        if node.children:
            return {*leaf_values(child) for child in node.children}
        else:
            return {node.value}


Specification
=============

In the grammar, the rules for comprehensions and generator expressions
would use ``star_named_expression`` instead of ``named_expression``::

    listcomp[expr_ty]:
        | '[' a=star_named_expression b=for_if_clauses ']' { _PyAST_ListComp(a, b, EXTRA) }
        | invalid_comprehension

    setcomp[expr_ty]:
        | '{' a=star_named_expression b=for_if_clauses '}' { _PyAST_SetComp(a, b, EXTRA) }
        | invalid_comprehension

    genexp[expr_ty]:
        | '(' a=star_named_expression b=for_if_clauses ')' { _PyAST_GeneratorExp(a, b, EXTRA) }
        | invalid_comprehension

(Small note: the current rule for ``genexp`` uses
``( assigment_expression | expression !':=')`` but this is equivalent to
``named_expression``.)

The rule for dictionary comprehensions would be adjusted to allow a new form as well::

    dictcomp[expr_ty]:
        | '{' a=kvpair b=for_if_clauses '}' { _PyAST_DictComp(a->key, a->value, b, EXTRA) }
        | '{' '**' a=expression b=for_if_clauses '}' { _PyAST_DictComp(a, NULL, b, EXTRA) }

The grammar rule for ``invalid_comprehension`` would be changed so that using
``*`` in a comprehension no longer raises a ``SyntaxError``, and the rule for
``invalid_dict_comprehension`` (which currently only checks for ``**`` being
used in a dictionary comprehension) would be removed.

The meaning of a starred expression in a list comprehension
``[*expr for x in it]`` is to treat each expression as an iterable, and
concatenate them, in the same way as if they were explicitly listed
via ``[*expr1, *expr2, ...]``.  Similarly, ``{*expr for x in it}``
forms a set union, as if the expressions were explicitly listed via
``{*expr1, *expr2, ...}``; and ``{**expr for x in it}`` combines
dictionaries, as if the expressions were explicitly listed via
``{**expr1, **expr2, ...}``.  As usual with sets and dictionaries,
repeated elements/keys replace earlier instances.

A generator expression ``(*expr for x in it)`` forms a generator producing
values from the concatenation of the iterables given by the expressions.
Specifically, the behavior is defined to be equivalent to the following
generator::

    def generator():
        for x in it:
            yield from expr


Backwards Compatibility
=======================

In versions 3.14 and earlier, the proposed notation generates a
``SyntaxError`` (via the ``invalid_comprehension`` and
``invalid_dict_comprehension`` rules in the CPython grammar).

The behavior of all comprehensions that are currently syntactically valid would
be unaffected by this change, so we do not anticipate much in the way of
backwards-incompatibility concerns (in principle, this change would only affect
code that relied on using unpacking operations in comprehensions raising
``SyntaxError``, which we expect to be rare).

We do anticipate the need for additional specific error messages related to
malformed comprehensions (including, for example, using ``**`` within a list
comprehension or generator expression).  That said, we expect a good number
of cases to be handled by the checks that are already in place.


How to Teach This
=================

Previously, ``out = [...x... for x in it]`` could be thought of as
equivalent to the following code::

    out = []
    for x in it:
        out.append(...x...)

This equivalence no longer holds when we allow ``*x`` in place of
``...x...``, because ``list.append`` accepts only a single argument.

With the new syntax, we can instead think of
``out = [...x... for x in it]`` as equivalent to the following code [#guido]_,
regardless of whether or not ``...x...`` uses ``*``::

    out = []
    for x in it:
        out.extend([...x...])

Similarly, we can think of ``out = {...x... for x in it}`` as equivalent to the
following code, regardless of whether or not ``...x...`` uses ``*`` or ``**``
or ``:``::

    out = set()
    for x in it:
        out.update({...x...})

These examples are equivalent in the sense that the output they produce would
be the same in both the version with the comprehension and the version without
it, but note that the non-comprehension version is slightly less efficient due
to making new lists/sets/dictionaries before each ``extend`` or ``update``, which
is unnecessary in the version that uses comprehensions.

Finally, we can think of ``out = (*...x... for x in it)``
(specifically the version that uses a ``*``) as equivalent to the
following code::

    def generator():
        for x in it:
            yield from ...x...
    out = generator()


Reference Implementation
========================

* `adqm/cpython:comprehension_unpacking <https://github.com/adqm/cpython/tree/comprehension_unpacking>`_


References
==========

.. [#guido] Message from Guido van Rossum
   (https://mail.python.org/archives/list/python-ideas@python.org/message/CQPULNM6PM623PLXF5Z63BIUZGOSQEKW/)


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
