PEP: 9999
Title: Unpacking in Comprehensions
Author: Adam Hartz <hz@mit.edu>, Erik Demaine <edemaine@mit.edu>
Sponsor: TBD
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 22-Jun-2025
Python-Version: 3.15
Post-History: `16-Oct-2021 <https://mail.python.org/archives/list/python-ideas@python.org/thread/7G732VMDWCRMWM4PKRG6ZMUKH7SUC7SH/>`__, `22-Jun-2025 <https://discuss.python.org/t/pre-pep-unpacking-in-comprehensions/96362>`__


Abstract
========

This PEP proposes extending list, set, and dictionary comprehensions, as well
as generator expressions, to allow unpacking notation (``*`` and ``**``) at the
start of the expression.  For example, ``[*it for it in its]`` becomes
shorthand for ``[x for it in its for x in it]``.  This notation makes it easy
to combine an arbitrary number of iterables into one list or set or generator,
or an arbitrary number of dictionaries into one dictionary.


Motivation
==========

Extended unpacking notation (``*`` and ``**``) from :pep:`448` makes it
easy to combine a few iterables or dictionaries::

    [*it1, *it2, *it3]  # list with the concatenation of three iterables
    {*it1, *it2, *it3}  # set with the union of three iterables
    {**dict1, **dict2, **dict3}  # dict with the combination of three dicts

But if we want to similarly combine an arbitrary number of iterables, we cannot
use unpacking in this same way.  Currently, we do have a few options.  We could
use explicit looping structures and built in means of combination::

    new_list = []
    for it in its:
        new_list.extend(it)

    new_set = set()
    for it in its:
        new_set.update(it)

    new_dict = {}
    for d in dicts:
        new_dict.update(d)

    def generator():
        for it in its:
            yield from it


Alternatively, we could be more concise by using a comprehension with two
loops::

    [x for it in its for x in it]
    {x for it in its for x in it}
    {key: value for d in dicts for key, value in d.items()}
    (x for it in its for x in it)

Or, we could use ``itertools.chain``::

    list(itertools.chain(*its))
    set(itertools.chain(*its))
    dict(itertools.chain(*(d.items() for d in dicts)))
    itertools.chain(*its)

As an additional alternative, this PEP proposes extending the unpacking pattern
to enable the use of ``*`` and ``**`` in comprehensions and generator
expressions, for example::

    [*it for it in its]  # list with the concatenation of iterables in 'its'
    {*it for it in its}  # set with the union of iterables in 'its'
    {**d for d in dicts} # dict with the combination of dicts in 'dicts'
    (*it for it in its)  # generator of the concatenation of iterables in 'its'

This proposal also extends to asynchronous comprehensions and generator
expressions, such that, for example, ``(*x async for x in aits())`` is
equivalent to ``(x async for ait in aits() for x in ait)``.

Rationale
=========

Combining iterable objects together into a single larger object is a common
task,  but the options currently available for performing this operation
require levels of indirection that can make the resulting code difficult to
read and understand.

The proposed notation is concise (avoiding the use and repetition of auxiliary
variables), and, we expect, intuitive and familiar to programmers familiar with
both comprehensions and unpacking notation.

This proposal was motivated in part by a written exam in a Python programming
class, where several students used the notation (specifically the ``set``
version) in their solutions, assuming that it already existed in Python.  This
suggests that the notation is intuitive, even to those who are learning Python.
By contrast, the existing syntax ``[x for it in its for x in it]`` is one that
students often get wrong, with the natural impulse for many students being to
reverse the order of the ``for`` clauses.

See :ref:`examples` for examples of code that could be rewritten more clearly
using the proposed syntax.


Specification
=============

Syntax
------

The necessary grammatical changes are allowing the expression in list/set
comprehensions and generator expressions to be preceded by a ``*``, and
allowing an alternative form of dictionary comprehension where the expression
is given by a single expression preceded by a ``**`` rather than a ``key:
value`` pair.

This can be accomplished by updating the ``listcomp`` and ``setcomp`` rules to
use ``star_named_expression`` instead of ``named_expression``::

    listcomp[expr_ty]:
        | '[' a=star_named_expression b=for_if_clauses ']'
        | invalid_comprehension

    setcomp[expr_ty]:
        | '{' a=star_named_expression b=for_if_clauses '}'
        | invalid_comprehension

The rule for ``genexp`` would similarly need to be modified to allow a ``starred_expression``::

    genexp[expr_ty]:
        | '(' a=(assignment_expression | expression !':=' | starred_expression) b=for_if_clauses ')'
        | invalid_comprehension

The rule for dictionary comprehensions would need to be adjusted as well, to allow for this new form::

    dictcomp[expr_ty]:
        | '{' a=kvpair b=for_if_clauses '}'
        | '{' '**' a=bitwise_or b=for_if_clauses '}'

We propose no additional changes to the way that argument unpacking for
function calls is handled, i.e., we propose retaining the rule that generator
expressions provided as the sole argument to functions do not require
additional redundant parentheses, i.e., that ``f(*x for x in it)`` should be
equivalent to ``f((*x for x in it))`` (see :ref:`functionargs` for more discussion).


Semantics: List/Set/Dict Comprehensions
---------------------------------------

The meaning of a starred expression in a list comprehension ``[*expr for x in
it]`` is to treat each expression as an iterable, and concatenate them, in the
same way as if they were explicitly listed via ``[*expr1, *expr2, ...]``.
Similarly, ``{*expr for x in it}`` forms a set union, as if the expressions
were explicitly listed via ``{*expr1, *expr2, ...}``; and ``{**expr for x in
it}`` combines dictionaries, as if the expressions were explicitly listed via
``{**expr1, **expr2, ...}``, retaining all of the equivalent semantics for
combining collections in this way (e.g., later values replacing earlier values
associated with the same key when combining dictionaries).

For list and set comprehensions, the generated bytecode between the starred and
unstarred version of the same comprehension should be identical, except for
replacing the opcode for adding a single element to the collection being built
up (``LIST_APPEND`` and ``SET_ADD``, respectively) with the opcode for
combining collections of that type (``LIST_EXTEND`` and ``SET_UPDATE``,
respectively).

Dictionary comprehensions should follow a similar pattern.  The resulting
bytecode will necessarily be somewhat different, but the key difference will be
the use of ``DICT_UPDATE`` instead of ``MAP_ADD`` as the way to add elements to
the new dictionary.

Semantics: Generator Expressions
--------------------------------

A generator expression ``(*expr for x in it)`` forms a generator producing
values from the concatenation of the iterables given by the expressions.
Specifically, the behavior is defined to be equivalent to the following
generator::

    def generator():
        for x in it:
            yield from expr

For synchronous generator expressions, the generated bytecode for the starred
and unstarred version of the same generator expression should be similar, but
the starred expression should using ``YIELD_FROM`` instead of ``YIELD_VALUE``
inside the loop.

For async generator expressions, ``(*expr async for x in ait())``, the equivalence
is more like the following::

    async def generator():
        async for x in ait():
            for i in expr:
                yield i

Since ``YIELD_FROM`` is not allowed inside of async generators, we instead
propose mimicking the functionality of the existing ``(z async for x in y for z
in x)`` syntax more directly.  The resulting bytecode for, for example, ``(*x
for x in y)`` should be the same as the bytecode for ``(z async for x in y for
z in x)``, with the natural exception of the ``STORE_FAST_LOAD_FAST`` used to
bind the variable ``z``.

For generator expressions that make use of the walrus operator ``:=`` from
:pep:`572`, note that we are not proposing changing the order of evaluation of
the various pieces of the comprehension, nor the rules around scoping.  So, for
example, in the expression ``(*(y := [i, i+1]) for i in (0, 2, 4))``, ``y``
will be defined (in the containing scope) as ``[0, 1]`` until just before the
resulting generator produces its third value, at which point the expression is
evaluated for its second time.

Error Reporting
---------------

Currently, the proposed syntax generates a ``SyntaxError`` (via the
``invalid_comprehension`` and ``invalid_dict_comprehension`` rules).

Allowing these forms to be recognized as syntactically valid requires changing
the grammar rule for ``invalid_comprehension`` so that using ``*`` in a
comprehension no longer raises a ``SyntaxError``, as well as removing the rule
for ``invalid_dict_comprehension`` (which currently only checks for ``**``
being used in a dictionary comprehension).

We also propose additional specific error messages in the following cases:

* Attempting to use ``**`` in a list comprehension or generator expression
  should report that dictionary unpacking cannot be used in those structures::

    invalid_comprehension:
        | '[' a='**' b=expression for_if_clauses {
            RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "dict unpacking cannot be used in list comprehension") }
        | '(' a='**' b=expression for_if_clauses {
            RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "dict unpacking cannot be used in generator expression") }
        ...


* The existing error error message for attempting to use ``*`` in a dictionary
  value should be retained, but we also propose reporting similar messages
  when attempting to use ``*`` or ``**`` unpacking on a dictionary key or value::

    invalid_double_starred_kvpairs:
        ...
        | a='*' b=bitwise_or ':' expression { RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "cannot use a starred expression in a dictionary key") }
        | a='**' b=bitwise_or ':' expression { RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "cannot use dict unpacking in a dictionary key") }
        | expression ':' a='*' b=bitwise_or { RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "cannot use a starred expression in a dictionary value") }
        | expression ':' a='**' b=bitwise_or { RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b, "cannot use dict unpacking in a dictionary value") }
        ...

.. _reference:

Reference Implementation
========================

A reference implementation is available at
`adqm/cpython:comprehension_unpacking
<https://github.com/adqm/cpython/tree/comprehension_unpacking>`_.

Backwards Compatibility
=======================

The behavior of all comprehensions that are currently syntactically valid would
be unaffected by this change, so we do not anticipate much in the way of
backwards-incompatibility concerns (in principle, this change would only affect
code that relied on using unpacking operations in comprehensions raising
``SyntaxError``, which we expect to be rare).

Rejected Alternative Proposals
==============================

The primary goal when thinking through the specification above was consistency
with existing norms around unpacking and comprehensions / generator
expressions.  One way to interpret this is that the goal was to write the
specification so as to require the smallest possible change(s) to the existing
grammar and code generation and letting the existing code inform the surrounding
semantics.

Below we discuss some of the common concerns/alternative proposals that have
come up in dicussions in the past but that are not included in this proposal.

.. _functionargs:

Starred Generators as Function Arguments
----------------------------------------

One common concern that has arisen multiple times (not only in our discussions
but also in previous discussions around this same idea) is a possible
syntactical ambiguity when passing a starred generator as the sole argument to
``f(*x for x in y)``.  In the original :pep:`448`, this ambiguity was cited as
a reason for not including a similar generalization as part of the proposal.

Our proposal is that ``f(*x for x in y)`` should be interpreted as ``f((*x for
x in y))`` and not attempt unpacking, but several alternatives were suggested
(or have been suggested) in the past, including:

* interpreting ``f(*x for x in y)`` as ``f(*(x for x in y)``,
* interpreting ``f(*x for x in y)`` as ``f(*(*x for x in y))``, or
* continuing to raise a ``SyntaxError`` for ``f(*x for x in y)`` even if the
  other aspects of this proposal are accepted.

The reason to prefer this proposal over these alternatives is the preservation
of existent conventions for punctuation around generator expressions.
Currently, the general rule is that generator expressions must be wrapped in
parentheses except when provided as the sole argument to a function, and we opt
for maintaining that rule even as we allow more kinds of generator expressions.
This option maintains a full symmetry between comprehensions and generator
expressions that use unpacking and those that don't.

Currently, we have the following conventions::

  f([x for x in y])  # pass in a single list
  f({x for x in y})  # pass in a single set
  f(x for x in y)  # pass in a single generator (no additional parentheses required around genexp)

  f(*[x for x in y])  # pass in elements from the list separately
  f(*{x for x in y})  # pass in elements from the set separately
  f(*(x for x in y))  # pass in elements from the generator separately (parentheses required)

This proposal opts to maintains those conventions even when the comprehensions
make use of unpacking::

  f([*x for x in y])  # pass in a single list
  f({*x for x in y})  # pass in a single set
  f(*x for x in y)  # pass in a single generator (no additional parentheses required around genexp)

  f(*[*x for x in y])  # pass in elements from the list separately
  f(*{*x for x in y})  # pass in elements from the set separately
  f(*(*x for x in y))  # pass in elements from the generator separately (parentheses required)


How to Teach This
=================

Currently, a common way to introduce the notion of comprehensions (which is
employed by the Python Tutorial) is to demonstrate equivalent code.  For
example, this method would say that, for example, ``out = [expr for x in it]``
is equivalent to the following code::

    out = []
    for x in it:
        out.append(expr)

Taking this approach, we can introduce ``out = [*expr for x in it]`` as instead
being equivalent to the following (which uses ``extend`` instead of
``append``::

    out = []
    for x in it:
        out.extend(expr)

Set and dict comprehensions that make use of unpacking can also be introduced
by a similar analogy::

    # equivalent to out = {expr for x in it}
    out = set()
    for x in it:
        out.add(expr)

    # equivalent to out = {*expr for x in it}
    out = set()
    for x in it:
        out.update(expr)

    # equivalent to out = {k_expr: v_expr for x in it}
    out = {}
    for x in it:
        out[k_expr] = v_expr

    # equivalent to out = {**expr for x in it}
    out = {}
    for x in it:
        out.update(expr)

And we can take a similar approach to illustrate the behavior of generator
expressions that involve unpacking::

    # equivalent to g = (expr for x in it)
    def generator():
        for x in it:
            yield expr
    g = generator()

    # equivalent to g = (*expr for x in it)
    def generator():
        for x in it:
            yield from expr

We can then generalize from these specific examples to the idea that,
wherever a non-starred comprehension/genexp would use an operator that
adds a single element to a collection, the starred would instead use
an operator that adds multiple elements to that collection.


Alternatively, we don't need to think of the two ideas as separate; instead,
with the new syntax, we can instead think of ``out = [...x... for x in it]`` as
equivalent to the following code [#guido]_, regardless of whether or not
``...x...`` uses ``*``::

    out = []
    for x in it:
        out.extend([...x...])

Similarly, we can think of ``out = {...x... for x in it}`` as equivalent to the
following code, regardless of whether or not ``...x...`` uses ``*`` or ``**``
or ``:``::

    out = set()
    for x in it:
        out.update({...x...})

These examples are equivalent in the sense that the output they produce would
be the same in both the version with the comprehension and the version without
it, but note that the non-comprehension version is slightly less efficient due
to making new lists/sets/dictionaries before each ``extend`` or ``update``, which
is unnecessary in the version that uses comprehensions.

.. _examples:

Code Examples
=============

This section shows some illustrative examples of how small pieces of code from
the standard library could be rewritten to make use of this new syntax to
improve consision and readability.  The :ref:`reference` continues to pass all
tests with these replacements made.

Replacing from_iterable and Friends
-----------------------------------

While not always the right choice, replacing ``itertools.chain.from_iterable``
and ``map`` can avoid an extra level of redirection, resulting in code that
follows conventional wisdom that comprehensions are more readable than
map/filter.

* From ``dataclasses.py``::

    # current:
    inherited_slots = set(
        itertools.chain.from_iterable(map(_get_slots, cls.__mro__[1:-1]))
    )

    # improved:
    inherited_slots = {*_get_slots(c) for c in cls.__mro__[1:-1]}

* From ``importlib/metadata/__init__.py``::

    # current:
    return itertools.chain.from_iterable(
        path.search(prepared) for path in map(FastPath, paths)
    )

    # improved:
    return (*FastPath(path).search(prepared) for path in paths)

* From ``collections/__init__.py`` (``Counter`` class)::

    # current:
    return _chain.from_iterable(_starmap(_repeat, self.items()))

    # improved:
    return (*_repeat(elt, num) for elt, num in self.items())

* From ``zipfile/_path/__init__.py``::

    # current:
    parents = itertools.chain.from_iterable(map(_parents, names))

    # improved:
    parents = (*_parents(name) for name in names)

* From ``_pyrepl/_module_completer.py``::

    # current:
    search_locations = set(chain.from_iterable(
        getattr(spec, 'submodule_search_locations', [])
        for spec in specs if spec
    ))

    # improved:
    search_locations = {
        *getattr(spec, 'submodule_search_locations', [])
        for spec in specs if spec
    }

Replacing Double Loops in Comprehensions
----------------------------------------

Replacing double loops in comprehensions avoids the need for defining and
referencing an auxiliary variable, reducing clutter.

* From ``multiprocessing.py``::

    # current:
    children = (child for path in self._paths for child in path.iterdir())

    # improved:
    children = (*path.iterdir() for path in self._paths)

* From ``Lib/asyncio/base_events.py``::

    # current:
    exceptions = [exc for sub in exceptions for exc in sub]

    # improved:
    exceptions = [*sub for sub in exceptions]

* From ``_weakrefset.py``::

    # current:
    return self.__class__(e for s in (self, other) for e in s)

    # improved:
    return self.__class__(*s for s in (self, other))


References
==========

.. [#guido] Message from Guido van Rossum
   (https://mail.python.org/archives/list/python-ideas@python.org/message/CQPULNM6PM623PLXF5Z63BIUZGOSQEKW/)

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
